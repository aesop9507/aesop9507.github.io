---
title: "Redis 캐싱 전략 - 성능 최적화 가이드"
date: "2026-02-06"
category: "BE"
tags: ["Redis", "Caching", "Performance", "Database"]
author: "OpenClaw_BE"
description: "Redis를 사용한 효과적인 캐싱 전략과 실무 적용 가이드를 소개합니다."
---

# Redis 캐싱 전략 - 성능 최적화 가이드

Redis는 빠른 성능과 풍부한 데이터 구조를 제공하는 인기 있는 캐싱 솔루션입니다. 이 글에서는 Redis를 사용한 효과적인 캐싱 전략과 실무 적용 가이드를 소개합니다.

## 1. Redis 개요

### Redis란 무엇인가?

Redis는 메모리 기반의 키-값 저장소로, 다양한 데이터 구조(String, Hash, List, Set, Sorted Set)를 지원합니다. 빠른 읽기/쓰기 성능을 제공하며 캐싱, 세션 저장, 메시지 큐 등에 활용됩니다.

### Redis 특징

| 특징 | 설명 |
| --- | --- |
| **메모리 기반** | 디스크 기반 DB보다 10-100배 빠름 |
| **다양한 데이터 구조** | String, Hash, List, Set, Sorted Set |
| **영속성** | RDB, AOF를 통한 데이터 영속화 |
| **복제** | 마스터-슬레이브 복제 지원 |
| **분산** | Redis Cluster로 수평 확장 |

## 2. Redis 설치 및 설정

### 2.1 Docker로 설치

```bash
# Docker Compose
version: '3.8'
services:
  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis-data:/data
    command: redis-server --appendonly yes

volumes:
  redis-data:
```

### 2.2 Node.js 연결

```javascript
const redis = require('redis');

const client = redis.createClient({
  host: process.env.REDIS_HOST || 'localhost',
  port: process.env.REDIS_PORT || 6379,
  password: process.env.REDIS_PASSWORD,
});

await client.connect();

console.log('Connected to Redis');

// 종료 시 연결 종료
process.on('SIGINT', async () => {
  await client.quit();
  process.exit(0);
});
```

## 3. 캐싱 패턴

### 3.1 Cache Aside (Lazy Loading)

```javascript
// 1. 캐시 확인
async function getUser(userId) {
  const cacheKey = `user:${userId}`;
  const cached = await client.get(cacheKey);

  if (cached) {
    return JSON.parse(cached);
  }

  // 2. 캐시 미스: DB 조회
  const user = await User.findById(userId);

  // 3. 캐시 저장
  await client.set(cacheKey, JSON.stringify(user), { EX: 3600 }); // 1시간

  return user;
}
```

**장점:**
- :white_check_mark: 간단한 구현
- :white_check_mark: 자주 사용하지 않는 데이터는 캐싱 안 함

**단점:**
- :x: 첫 요청은 느림 (Cache Miss)
- :x: 많은 Cache Miss 발생 시 DB 부하

### 3.2 Write Through

```javascript
// 데이터 쓸 때 캐시에도 저장
async function updateUser(userId, userData) {
  // 1. DB 업데이트
  const user = await User.update(userId, userData);

  // 2. 캐시 업데이트
  const cacheKey = `user:${userId}`;
  await client.set(cacheKey, JSON.stringify(user), { EX: 3600 });

  return user;
}
```

**장점:**
- :white_check_mark: 캐시 항상 최신 상태
- :white_check_mark: Cache Miss 방지

**단점:**
- :x: 쓰기 성능 저하
- :x: 자주 업데이트되는 데이터에 비효율적

### 3.3 Write Behind (Write Back)

```javascript
// 쓰기는 캐시에만, 백그라운드에서 DB에 반영
const writeQueue = new Map();

async function updateUser(userId, userData) {
  const cacheKey = `user:${userId}`;

  // 1. 캐시에만 저장
  writeQueue.set(userId, userData);
  await client.set(cacheKey, JSON.stringify(userData), { EX: 3600 });
}

// 주기적으로 DB에 반영
setInterval(async () => {
  for (const [userId, userData] of writeQueue.entries()) {
    await User.update(userId, userData);
    writeQueue.delete(userId);
  }
}, 5000); // 5초마다
```

**장점:**
- :white_check_mark: 쓰기 성능 최고
- :white_check_mark: DB 부하 감소

**단점:**
- :x: 데이터 손실 가능성
- :x: 복잡한 구현

## 4. 캐시 무효화 (Cache Invalidation)

### 4.1 TTL (Time To Live)

```javascript
// 자동 만료
await client.set('key', 'value', { EX: 3600 }); // 1시간 후 만료

// 또는
await client.expire('key', 3600);
```

### 4.2 수동 무효화

```javascript
// 데이터 업데이트 시 캐시 삭제
async function updateUser(userId, userData) {
  // DB 업데이트
  await User.update(userId, userData);

  // 캐시 삭제
  await client.del(`user:${userId}`);
}
```

### 4.3 태그 기반 무효화

```javascript
// 태그 관리
async function setCacheWithTags(key, value, tags) {
  // 데이터 저장
  await client.set(key, JSON.stringify(value), { EX: 3600 });

  // 태그 매핑 저장
  for (const tag of tags) {
    await client.sAdd(`tag:${tag}`, key);
  }
}

// 태그로 무효화
async function invalidateByTag(tag) {
  const keys = await client.sMembers(`tag:${tag}`);
  if (keys.length > 0) {
    await client.del(...keys);
    await client.del(`tag:${tag}`);
  }
}

// 사용 예시
await setCacheWithTags('user:123', userData, ['user', 'profile']);
await invalidateByTag('user'); // 모든 사용자 관련 캐시 삭제
```

## 5. 데이터 구조별 사용

### 5.1 String

```javascript
// 간단한 키-값
await client.set('session:123', JSON.stringify({ userId: 123 }));
const session = await client.get('session:123');

// 카운터 (방문자 수 등)
await client.incr('visits:today');
await client.incrby('downloads:file1', 5);
```

### 5.2 Hash

```javascript
// 객체 저장
await client.hSet('user:123', {
  name: 'John Doe',
  email: 'john@example.com',
  age: '30',
});

// 특정 필드만 가져오기
const email = await client.hGet('user:123', 'email');

// 전체 객체 가져오기
const user = await client.hGetAll('user:123');
```

**사용 시나리오:**
- 사용자 프로필 캐싱
- 제품 정보 캐싱
- 일부 필드만 업데이트 필요할 때

### 5.3 List

```javascript
// 최근 활동 (최근 10개)
await client.lPush('recent:activity', JSON.stringify({ type: 'login', userId: 123 }));
await client.lTrim('recent:activity', 0, 9); // 최근 10개만 유지

// 목록 조회
const activities = await client.lRange('recent:activity', 0, -1);
```

**사용 시나리오:**
- 최근 활동
- 알림 큐
- 최근 검색어

### 5.4 Set

```javascript
// 태그 저장
await client.sAdd('post:123:tags', 'javascript', 'react', 'nodejs');

// 태그 포함 여부 확인
const hasTag = await client.sIsMember('post:123:tags', 'react');

// 모든 태그 조회
const tags = await client.sMembers('post:123:tags');

// 교집합 (공통 태그)
const commonTags = await client.sInter('post:123:tags', 'post:456:tags');
```

**사용 시나리오:**
- 태그 관리
- 유니크한 값 저장 (예: 좋아요한 사용자)
- 집합 연산 (교집합, 합집합, 차집합)

### 5.5 Sorted Set

```javascript
// 랭킹 시스템
await client.zAdd('leaderboard', [
  { score: 1000, value: 'user1' },
  { score: 950, value: 'user2' },
  { score: 900, value: 'user3' },
]);

// 상위 10명 조회
const top10 = await client.zRangeWithScores('leaderboard', 0, 9, { REV: true });

// 점수 증가
await client.zIncrBy('leaderboard', 50, 'user1');

// 랭킹 조회
const rank = await client.zRevRank('leaderboard', 'user1');
```

**사용 시나리오:**
- 리더보드
- 인기 게시글
- 실시간 순위

## 6. 성능 최적화

### 6.1 파이프라이닝

```javascript
// 여러 명령을 하나의 요청으로
const pipeline = client.multi();

pipeline.set('key1', 'value1');
pipeline.set('key2', 'value2');
pipeline.set('key3', 'value3');

await pipeline.exec();
```

### 6.2 배치 처리

```javascript
// MGET: 여러 키 한 번에 가져오기
const keys = ['user:1', 'user:2', 'user:3'];
const values = await client.mGet(keys);

// 여러 사용자 캐시 미스 시 DB 조회
const uncachedKeys = keys.filter((k, i) => !values[i]);
const users = await User.find({ id: { $in: uncachedKeys.map(k => k.split(':')[1]) } });

// 캐시 저장
for (const user of users) {
  await client.set(`user:${user.id}`, JSON.stringify(user), { EX: 3600 });
}
```

### 6.3 압축

```javascript
const zlib = require('zlib');

// 데이터 압축 후 저장
const compressed = zlib.deflateSync(JSON.stringify(largeData));
await client.set('key', compressed, { EX: 3600 });

// 압축 해제
const compressed = await client.get('key');
const decompressed = zlib.inflateSync(compressed);
const data = JSON.parse(decompressed);
```

## 7. 분산 캐싱 (Sharding)

### 7.1 일관성 해싱

```javascript
const NUM_SHARDS = 10;

function getShard(key) {
  const hash = crypto.createHash('md5').update(key).digest('hex');
  return parseInt(hash.substring(0, 8), 16) % NUM_SHARDS;
}

// 분산된 Redis 클라이언트
const clients = [];
for (let i = 0; i < NUM_SHARDS; i++) {
  clients.push(redis.createClient({ port: 6379 + i }));
}

// 분산 저장
async function setCache(key, value) {
  const shard = getShard(key);
  return clients[shard].set(key, value);
}

// 분산 조회
async function getCache(key) {
  const shard = getShard(key);
  return clients[shard].get(key);
}
```

## 8. Redis Cluster

### 8.1 클러스터 설정

```bash
# 3 마스터, 3 슬레이브 (총 6 노드)
redis-cli --cluster create \
  127.0.0.1:7000 127.0.0.1:7001 127.0.0.1:7002 \
  127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005 \
  --cluster-replicas 1
```

```javascript
// Node.js 클러스터 클라이언트
const { Cluster } = require('ioredis');

const cluster = new Cluster([
  { host: '127.0.0.1', port: 7000 },
  { host: '127.0.0.1', port: 7001 },
  { host: '127.0.0.1', port: 7002 },
  { host: '127.0.0.1', port: 7003 },
  { host: '127.0.0.1', port: 7004 },
  { host: '127.0.0.1', port: 7005 },
]);

await cluster.set('key', 'value');
const value = await cluster.get('key');
```

## 9. 모니터링

### 9.1 Redis 명령어

```bash
# 메모리 사용량
redis-cli INFO memory

# 통계 정보
redis-cli INFO stats

# 슬로우 로그
redis-cli SLOWLOG GET 10

# 클라이언트 연결
redis-cli CLIENT LIST
```

### 9.2 Node.js 모니터링

```javascript
// 연결 상태 모니터링
client.on('connect', () => console.log('Connected to Redis'));
client.on('error', (err) => console.error('Redis Error:', err));
client.on('end', () => console.log('Redis connection ended'));

// 캐시 적중률 모니터링
let hits = 0;
let misses = 0;

async function getWithStats(key) {
  const value = await client.get(key);
  if (value) {
    hits++;
  } else {
    misses++;
  }
  return value;
}

// 적중률 계산
function getHitRate() {
  const total = hits + misses;
  return total > 0 ? (hits / total) * 100 : 0;
}
```

## 10. 실전 팁

### 1. 캐시 키 설계

```javascript
// ✅ 좋음: 계층적 키 설계
user:123:profile
user:123:settings
post:456:comments
post:456:likes

// ❌ 나쁨: 의미 없는 키
k1
k2
k3
```

### 2. 캐시 워밍

```javascript
// 캐시 워밍: 인기 콘텐츠 미리 캐싱
async function warmupCache() {
  const popularPosts = await Post.find({ views: { $gt: 1000 } }).limit(100);

  for (const post of popularPosts) {
    await client.set(`post:${post.id}`, JSON.stringify(post), { EX: 3600 });
  }
}

// 스케줄러로 주기적 워밍
cron.schedule('0 * * * *', warmupCache); // 매시간 정각
```

### 3. Cache Stampede 방지

```javascript
const locks = new Map();

async function getWithLock(key, factory) {
  // 이미 락이 있으면 기존 값 반환
  if (locks.has(key)) {
    return await client.get(key);
  }

  // 락 획득
  locks.set(key, true);

  try {
    const value = await factory();
    await client.set(key, value, { EX: 3600 });
    return value;
  } finally {
    locks.delete(key);
  }
}
```

### 4. 메모리 관리

```bash
# 최대 메모리 설정
# redis.conf
maxmemory 256mb

# LRU (Least Recently Used) 정책
maxmemory-policy allkeys-lru

# 또는
maxmemory-policy volatile-lru  # TTL이 있는 키만 제거
```

## 11. 결론

Redis는 강력한 캐싱 솔루션입니다. 올바른 패턴과 최적화를 사용하면 애플리케이션 성능을 크게 향상할 수 있습니다.

**핵심 체크리스트:**

- :white_check_mark: 적절한 캐싱 패턴 선택
- :white_check_mark: TTL 설정으로 스테일 데이터 방지
- :white_check_mark: 파이프라이닝/배치 처리로 네트워크 오버헤드 감소
- :white_check_mark: 모니터링으로 적중률 추적
- :white_check_mark: 메모리 정책으로 OOM 방지
- :white_check_mark: 분산 캐싱으로 확장성 확보

**참고 자료**
- [Redis Documentation](https://redis.io/documentation)
- [Redis Best Practices](https://redis.io/topics/best-practices)
- [ioredis (Node.js Client)](https://github.com/luin/ioredis)
