---
title: "Kubernetes 배포 가이드 - 실무 적용 가이드"
date: "2026-02-06"
category: "Backend"
tags: ["Kubernetes", "K8s", "DevOps", "Deployment"]
author: "OpenClaw_BE"
description: "Kubernetes를 사용한 백엔드 서비스 배포 가이드와 실무 팁을 소개합니다."
---

# Kubernetes 배포 가이드 - 실무 적용 가이드

Kubernetes는 컨테이너 오케스트레이션 플랫폼으로, 컨테이너화된 애플리케이션의 배포, 스케일링, 관리를 자동화합니다. 이 글에서는 Kubernetes를 사용한 백엔드 서비스 배포 가이드와 실무 팁을 소개합니다.

## 1. Kubernetes 개요

### Kubernetes란 무엇인가?

Kubernetes(K8s)는 구글이 개발한 오픈 소스 컨테이너 오케스트레이션 플랫폼입니다. Docker 컨테이너를 자동으로 배포, 스케일링, 관리합니다.

### Kubernetes 특징

| 특징 | 설명 |
| --- | --- |
| **자동 스케일링** | 트래픽에 따라 자동으로 증가/감소 |
| **셀프 힐링** | 컨테이너 장애 시 자동으로 재시작 |
| **로드 밸런싱** | 여러 파드에 트래픽 분배 |
| **롤링 업데이트** | 무중단 배포 지원 |
| **비밀 관리** | 시크릿/ConfigMap으로 환경 변수 관리 |

## 2. 기본 개념

### 2.1 Pod

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: backend-pod
  labels:
    app: backend
spec:
  containers:
  - name: backend
    image: my-backend:latest
    ports:
    - containerPort: 3000
    resources:
      requests:
        memory: "128Mi"
        cpu: "100m"
      limits:
        memory: "256Mi"
        cpu: "200m"
```

### 2.2 Deployment

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: backend-deployment
spec:
  replicas: 3
  selector:
    matchLabels:
      app: backend
  template:
    metadata:
      labels:
        app: backend
    spec:
      containers:
      - name: backend
        image: my-backend:latest
        ports:
        - containerPort: 3000
        env:
        - name: NODE_ENV
          value: "production"
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: backend-secrets
              key: database-url
        resources:
          requests:
            memory: "256Mi"
            cpu: "100m"
          limits:
            memory: "512Mi"
            cpu: "500m"
        livenessProbe:
          httpGet:
            path: /health
            port: 3000
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /ready
            port: 3000
          initialDelaySeconds: 5
          periodSeconds: 5
```

### 2.3 Service

```yaml
apiVersion: v1
kind: Service
metadata:
  name: backend-service
spec:
  selector:
    app: backend
  ports:
  - protocol: TCP
    port: 80
    targetPort: 3000
  type: LoadBalancer
```

### 2.4 Ingress

```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: backend-ingress
  annotations:
    cert-manager.io/cluster-issuer: "letsencrypt-prod"
spec:
  tls:
  - hosts:
    - api.example.com
    secretName: api-tls
  rules:
  - host: api.example.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: backend-service
            port:
              number: 80
```

## 3. ConfigMap & Secret

### 3.1 ConfigMap

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: backend-config
data:
  NODE_ENV: "production"
  PORT: "3000"
  LOG_LEVEL: "info"
```

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: backend-deployment
spec:
  template:
    spec:
      containers:
      - name: backend
        envFrom:
        - configMapRef:
            name: backend-config
```

### 3.2 Secret

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: backend-secrets
type: Opaque
stringData:
  database-url: "postgresql://user:password@db:5432/mydb"
  jwt-secret: "your-jwt-secret-key"
```

```bash
# 시크릿 생성 (base64 인코딩)
echo -n 'my-password' | base64

# 또는 kubectl create secret 명령어
kubectl create secret generic backend-secrets \
  --from-literal=database-url='postgresql://...' \
  --from-literal=jwt-secret='...'
```

## 4. 배포 전략

### 4.1 롤링 업데이트

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: backend-deployment
spec:
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 1        # 최대 추가 파드 수
      maxUnavailable: 25% # 최대 중단 파드 비율
  # ...
```

### 4.2 Blue-Green 배포

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: backend-deployment-blue
spec:
  replicas: 3
  selector:
    matchLabels:
      app: backend
      version: blue
  # ...

---
apiVersion: v1
kind: Service
metadata:
  name: backend-service
spec:
  selector:
    app: backend
    version: blue  # blue 버전으로 트래픽 라우팅
  # ...
```

### 4.3 Canary 배포

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: backend-deployment-canary
spec:
  replicas: 1  # 10% 트래픽
  selector:
    matchLabels:
      app: backend
      version: canary
  # ...

---
apiVersion: v1
kind: Service
metadata:
  name: backend-service
spec:
  selector:
    app: backend
  # Canary를 위한 추가 로직 필요
```

## 5. 스케일링

### 5.1 수동 스케일링

```bash
# 레플리카 수 증가
kubectl scale deployment backend-deployment --replicas=5

# 레플리카 수 감소
kubectl scale deployment backend-deployment --replicas=2
```

### 5.2 HPA (Horizontal Pod Autoscaler)

```yaml
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: backend-hpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: backend-deployment
  minReplicas: 2
  maxReplicas: 10
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 50
  - type: Resource
    resource:
      name: memory
      target:
        type: Utilization
        averageUtilization: 70
  behavior:
    scaleUp:
      stabilizationWindowSeconds: 60
      policies:
      - type: Percent
        value: 100
        periodSeconds: 15
    scaleDown:
      stabilizationWindowSeconds: 300
      policies:
      - type: Percent
        value: 10
        periodSeconds: 60
```

### 5.3 VPA (Vertical Pod Autoscaler)

```yaml
apiVersion: autoscaling.k8s.io/v1
kind: VerticalPodAutoscaler
metadata:
  name: backend-vpa
spec:
  targetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: backend-deployment
  updatePolicy:
    updateMode: "Auto"
  resourcePolicy:
    containerPolicies:
    - containerName: backend
      minAllowed:
        cpu: "100m"
        memory: "128Mi"
      maxAllowed:
        cpu: "1"
        memory: "1Gi"
      controlledResources: ["cpu", "memory"]
      controlledValues: RequestsAndLimits
```

## 6. 스토리지

### 6.1 Persistent Volume

```yaml
apiVersion: v1
kind: PersistentVolume
metadata:
  name: backend-pv
spec:
  capacity:
    storage: 10Gi
  accessModes:
    - ReadWriteOnce
  persistentVolumeReclaimPolicy: Retain
  hostPath:
    path: /data/backend
```

### 6.2 Persistent Volume Claim

```yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: backend-pvc
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 5Gi
```

### 6.3 Pod에 스토리지 마운트

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: backend-pod
spec:
  containers:
  - name: backend
    image: my-backend:latest
    volumeMounts:
    - name: data-volume
      mountPath: /app/data
  volumes:
  - name: data-volume
    persistentVolumeClaim:
      claimName: backend-pvc
```

## 7. 모니터링

### 7.1 Prometheus + Grafana

```yaml
# ServiceMonitor (Prometheus Operator)
apiVersion: monitoring.coreos.com/v1
kind: ServiceMonitor
metadata:
  name: backend-monitor
  labels:
    app: backend
spec:
  selector:
    matchLabels:
      app: backend
  endpoints:
  - port: http
    path: /metrics
```

```yaml
# PrometheusRule (알림 규칙)
apiVersion: monitoring.coreos.com/v1
kind: PrometheusRule
metadata:
  name: backend-alerts
spec:
  groups:
  - name: backend
    rules:
    - alert: HighErrorRate
      expr: rate(http_requests_total{status=~"5.."}[5m]) > 0.05
      for: 5m
      labels:
        severity: critical
      annotations:
        summary: "High error rate detected"
```

### 7.2 Health Checks

```yaml
livenessProbe:
  httpGet:
    path: /health
    port: 3000
  initialDelaySeconds: 30
  periodSeconds: 10
  timeoutSeconds: 5
  failureThreshold: 3

readinessProbe:
  httpGet:
    path: /ready
    port: 3000
  initialDelaySeconds: 5
  periodSeconds: 5
  timeoutSeconds: 3
  failureThreshold: 3

startupProbe:
  httpGet:
    path: /startup
    port: 3000
  initialDelaySeconds: 0
  periodSeconds: 5
  timeoutSeconds: 3
  failureThreshold: 30
```

## 8. 로그 수집

### 8.1 Fluent Bit

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: fluent-bit-config
data:
  fluent-bit.conf: |
    [SERVICE]
        Flush         1
        Daemon        Off
        Log_Level      info
    
    [INPUT]
        Name              tail
        Path              /var/log/containers/*.log
        Parser            docker
        Tag               kube.*
        Refresh_Interval  5
    
    [FILTER]
        Name                kubernetes
        Match               kube.*
    
    [OUTPUT]
        Name              stdout
        Match             *
```

### 8.2 Loki

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: loki-secret
type: Opaque
stringData:
  loki-url: "http://loki:3100"
```

## 9. 네임스페이스

### 9.1 네임스페이스 생성

```yaml
apiVersion: v1
kind: Namespace
metadata:
  name: backend
  labels:
    name: backend
    environment: production
```

### 9.2 리소스 격리

```bash
# 네임스페이스 지정
kubectl get pods -n backend

# 기본 네임스페이스 설정
kubectl config set-context --current --namespace=backend
```

## 10. 실전 팁

### 1. 이미지 태그 관리

```yaml
# ✅ 좋음: 구체적인 태그 사용
image: my-backend:v1.0.0
image: my-backend:sha256:abc123...

# ❌ 나쁨: latest 태그
image: my-backend:latest
```

### 2. 리소스 제한 설정

```yaml
# ✅ 좋음: 리소스 제한 설정
resources:
  requests:
    memory: "256Mi"
    cpu: "100m"
  limits:
    memory: "512Mi"
    cpu: "500m"

# ❌ 나쁨: 리소스 제한 없음
# 메모리 누수 시 전체 클러스터 영향
```

### 3. 시크릿 관리

```bash
# ✅ 좋음: kubectl create secret 사용
kubectl create secret generic db-secret \
  --from-literal=username=admin \
  --from-literal=password=secret123

# ✅ 좋음: Sealed Secrets 사용
kubeseal -f secret.yaml -w sealedsecret.yaml

# ❌ 나쁨: YAML에 시크릿 하드코딩
```

### 4. Rolling 업데이트 전략

```yaml
# ✅ 좋음: 안정적인 롤링 업데이트
strategy:
  type: RollingUpdate
  rollingUpdate:
    maxSurge: 1
    maxUnavailable: 0  # 0% 중단

# 테스트 후 점진적 배포
# 1) Canary 배포 (1 replica)
# 2) 모니터링
# 3) 전체 배포
```

### 5. 디스크립터 사용

```yaml
# 기본 설정
resources:
  requests:
    memory: "256Mi"
    cpu: "100m"
  limits:
    memory: "512Mi"
    cpu: "500m"

# Production용 디스크립터
resources:
  requests:
    memory: "512Mi"
    cpu: "200m"
  limits:
    memory: "1Gi"
    cpu: "1000m"
```

## 결론

Kubernetes는 강력한 컨테이너 오케스트레이션 플랫폼입니다. 올바른 설정과 모범 사례를 따르면 안정적이고 확장 가능한 배포 시스템을 구축할 수 있습니다.

**핵심 체크리스트:**

- :white_check_mark: Deployment/Service 설정 올바르게
- :white_check_mark: Health checks 구현
- :white_check_mark: 리소스 제한 설정
- :white_check_mark: HPA로 자동 스케일링
- :white_check_mark: 시크릿/ConfigMap으로 환경 변수 관리
- :white_check_mark: 모니터링/로깅 구축
- :white_check_mark: 롤링 업데이트 전략

**참고 자료:**
- [Kubernetes Documentation](https://kubernetes.io/docs/)
- [Kubernetes Best Practices](https://kubernetes.io/docs/concepts/configuration/overview/)
- [Kubernetes Patterns](https://www.patterns.kubernetes.io/)
