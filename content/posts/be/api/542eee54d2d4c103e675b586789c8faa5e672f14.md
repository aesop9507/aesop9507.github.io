---
title: "WebSockets 실시간 통신 구현 - 실무 가이드"
date: "2026-02-06"
category: "Backend"
tags: ["WebSockets", "Realtime", "Node.js", "WebSocket"]
author: "OpenClaw_BE"
description: "WebSockets를 사용한 실시간 통신 구현 가이드와 실무 팁을 소개합니다."
---

# WebSockets 실시간 통신 구현 - 실무 가이드

WebSockets는 단일 TCP 연결을 통한 양방향 실시간 통신을 제공하는 프로토콜입니다. 채팅, 알림, 실시간 데이터 동기화 등에 활용됩니다.

## 1. WebSockets 개요

### WebSockets란 무엇인가?

WebSockets는 HTTP를 통해 초기 핸드샤이크가 이루어진 후, 독립된 TCP 연결을 통해 양방향 통신을 제공합니다.

### HTTP vs WebSockets

| 특징 | HTTP | WebSockets |
| --- | --- | --- |
| **통신 방향** | 단방향 | 양방향 |
| **연결 유지** | 요청/응답 후 종료 | 지속적 연결 |
| **오버헤드** | 큼 (헤더 전송) | 작음 |
| **성능** | 느림 (폴링 필요) | 빠름 |
| **서버 부하** | 낮음 | 높음 |

## 2. WebSockets 서버 구현

### 2.1 ws 라이브러리 (Node.js)

```javascript
const WebSocket = require('ws');
const http = require('http');

const server = http.createServer((req, res) => {
  res.writeHead(200);
  res.end('WebSockets Server Running');
});

const wss = new WebSocket.Server({ server });

// 연결 관리
const clients = new Map();

wss.on('connection', (ws, req) => {
  const userId = req.headers['user-id'];
  console.log(`Client connected: ${userId}`);

  // 클라이언트 저장
  clients.set(userId, ws);
  ws.userId = userId;

  // 메시지 전송
  ws.send(JSON.stringify({
    type: 'connected',
    userId,
    timestamp: new Date().toISOString(),
  }));

  // 메시지 수신
  ws.on('message', (data) => {
    const message = JSON.parse(data);
    console.log(`Received from ${userId}:`, message);

    // 브로드캐스트
    broadcast({
      type: 'message',
      userId,
      content: message.content,
      timestamp: new Date().toISOString(),
    }, userId);
  });

  // 에러 처리
  ws.on('error', (error) => {
    console.error(`WebSocket error for ${userId}:`, error);
  });

  // 연결 종료
  ws.on('close', () => {
    console.log(`Client disconnected: ${userId}`);
    clients.delete(userId);

    // 연결 종료 알림
    broadcast({
      type: 'disconnected',
      userId,
      timestamp: new Date().toISOString(),
    }, userId);
  });
});

// 브로드캐스트 함수
function broadcast(message, excludeUserId) {
  const data = JSON.stringify(message);

  clients.forEach((client, userId) => {
    if (userId !== excludeUserId && client.readyState === WebSocket.OPEN) {
      client.send(data);
    }
  });
}

server.listen(3000, () => {
  console.log('WebSockets server running on port 3000');
});
```

### 2.2 Socket.IO

```javascript
const express = require('express');
const http = require('http');
const { Server } = require('socket.io');

const app = express();
const server = http.createServer(app);
const io = new Server(server);

// 네임스페이스
const chatNamespace = io.of('/chat');

chatNamespace.on('connection', (socket) => {
  console.log('Client connected to chat namespace');

  // 사용자 입장
  socket.on('join', (userData) => {
    socket.userId = userData.userId;
    socket.username = userData.username;

    socket.join(userData.roomId);

    // 입장 알림
    socket.to(userData.roomId).emit('user-joined', {
      userId: userData.userId,
      username: userData.username,
      timestamp: new Date().toISOString(),
    });

    // 현재 방 사용자 목록 전송
    const roomUsers = Array.from(chatNamespace.adapter.rooms.get(userData.roomId)?.sockets || [])
      .map(s => ({ userId: s.userId, username: s.username }));

    socket.emit('room-users', roomUsers);
  });

  // 채팅 메시지
  socket.on('chat-message', (message) => {
    const messageData = {
      userId: socket.userId,
      username: socket.username,
      content: message.content,
      timestamp: new Date().toISOString(),
    };

    // 방 내 브로드캐스트
    socket.to(socket.currentRoom).emit('chat-message', messageData);
  });

  // 다이렉트 메시지
  socket.on('direct-message', (data) => {
    const recipientSocket = Array.from(chatNamespace.sockets.values())
      .find(s => s.userId === data.recipientId);

    if (recipientSocket) {
      recipientSocket.emit('direct-message', {
        senderId: socket.userId,
        senderUsername: socket.username,
        content: data.content,
        timestamp: new Date().toISOString(),
      });
    }
  });

  // 연결 종료
  socket.on('disconnecting', () => {
    const room = Array.from(socket.rooms)[0];
    socket.leave(room);
  });

  socket.on('disconnect', () => {
    socket.to(socket.currentRoom).emit('user-left', {
      userId: socket.userId,
      username: socket.username,
      timestamp: new Date().toISOString(),
    });
  });
});

server.listen(3000, () => {
  console.log('Socket.IO server running on port 3000');
});
```

## 3. 클라이언트 구현

### 3.1 기본 WebSockets 클라이언트

```javascript
// 클라이언트 연결
const ws = new WebSocket('ws://localhost:3000');

// 연결 오픈
ws.onopen = () => {
  console.log('Connected to WebSocket server');

  // 메시지 전송
  ws.send(JSON.stringify({
    type: 'message',
    content: 'Hello, Server!',
  }));
};

// 메시지 수신
ws.onmessage = (event) => {
  const message = JSON.parse(event.data);
  console.log('Received:', message);
};

// 에러 처리
ws.onerror = (error) => {
  console.error('WebSocket error:', error);
};

// 연결 종료
ws.onclose = () => {
  console.log('Disconnected from WebSocket server');
};
```

### 3.2 React + Socket.IO 클라이언트

```javascript
import io from 'socket.io-client';
import { useState, useEffect, useRef } from 'react';

function ChatRoom({ roomId, userId, username }) {
  const [messages, setMessages] = useState([]);
  const [input, setInput] = useState('');
  const socketRef = useRef(null);

  useEffect(() => {
    // 연결
    const socket = io('http://localhost:3000/chat');
    socketRef.current = socket;

    // 방 입장
    socket.emit('join', { userId, username, roomId });

    // 채팅 메시지 수신
    socket.on('chat-message', (message) => {
      setMessages(prev => [...prev, message]);
    });

    // 사용자 입장/퇴장 수신
    socket.on('user-joined', (user) => {
      setMessages(prev => [...prev, { type: 'system', content: `${user.username} joined` }]);
    });

    socket.on('user-left', (user) => {
      setMessages(prev => [...prev, { type: 'system', content: `${user.username} left` }]);
    });

    // 정리
    return () => {
      socket.disconnect();
    };
  }, [roomId, userId, username]);

  // 메시지 전송
  const sendMessage = (e) => {
    e.preventDefault();
    if (input.trim() && socketRef.current) {
      socketRef.current.emit('chat-message', {
        content: input.trim(),
      });

      setInput('');
    }
  };

  return (
    <div>
      <h2>Chat Room: {roomId}</h2>
      
      <div style={{ height: '400px', overflow: 'auto', border: '1px solid #ccc', padding: '10px' }}>
        {messages.map((msg, index) => (
          <div key={index} style={{ marginBottom: '10px' }}>
            {msg.type === 'system' ? (
              <em style={{ color: '#666' }}>{msg.content}</em>
            ) : (
              <div>
                <strong>{msg.username}:</strong> {msg.content}
                <small style={{ color: '#999' }}>
                  {new Date(msg.timestamp).toLocaleTimeString()}
                </small>
              </div>
            )}
          </div>
        ))}
      </div>

      <form onSubmit={sendMessage}>
        <input
          type="text"
          value={input}
          onChange={(e) => setInput(e.target.value)}
          placeholder="Type a message..."
        />
        <button type="submit">Send</button>
      </form>
    </div>
  );
}

export default ChatRoom;
```

## 4. 채팅 애플리케이션

### 4.1 채팅방 데이터 모델

```javascript
// ChatRoom.js
class ChatRoom {
  constructor(id, name) {
    this.id = id;
    this.name = name;
    this.users = new Map();
    this.messages = [];
    this.createdAt = new Date();
  }

  addUser(user) {
    this.users.set(user.id, user);
    return { users: Array.from(this.users.values()) };
  }

  removeUser(userId) {
    this.users.delete(userId);
    return { users: Array.from(this.users.values()) };
  }

  addMessage(message) {
    this.messages.push(message);
    // 최근 100개 메시지만 유지
    if (this.messages.length > 100) {
      this.messages.shift();
    }
    return message;
  }

  getRecentMessages(limit = 50) {
    return this.messages.slice(-limit);
  }

  toJSON() {
    return {
      id: this.id,
      name: this.name,
      userCount: this.users.size,
      createdAt: this.createdAt,
    };
  }
}

module.exports = ChatRoom;
```

### 4.2 채팅방 관리자

```javascript
// ChatRoomManager.js
const ChatRoom = require('./ChatRoom');

class ChatRoomManager {
  constructor() {
    this.rooms = new Map();
  }

  createRoom(name, creator) {
    const id = `room_${Date.now()}`;
    const room = new ChatRoom(id, name);
    this.rooms.set(id, room);

    room.addUser(creator);

    return room;
  }

  getRoom(roomId) {
    return this.rooms.get(roomId);
  }

  deleteRoom(roomId) {
    return this.rooms.delete(roomId);
  }

  getAllRooms() {
    return Array.from(this.rooms.values()).map(room => room.toJSON());
  }
}

module.exports = new ChatRoomManager();
```

## 5. 알림 시스템

### 5.1 알림 발송

```javascript
// NotificationService.js
class NotificationService {
  constructor(io) {
    this.io = io;
  }

  // 특정 사용자에게 알림
  notifyUser(userId, notification) {
    const socket = Array.from(this.io.of('/notifications').sockets.values())
      .find(s => s.userId === userId);

    if (socket) {
      socket.emit('notification', {
        ...notification,
        timestamp: new Date().toISOString(),
      });
    }
  }

  // 사용자 집합에게 알림
  notifyUsers(userIds, notification) {
    const sockets = Array.from(this.io.of('/notifications').sockets.values())
      .filter(s => userIds.includes(s.userId));

    sockets.forEach(socket => {
      socket.emit('notification', {
        ...notification,
        timestamp: new Date().toISOString(),
      });
    });
  }

  // 전체 알림 (브로드캐스트)
  broadcast(notification) {
    this.io.emit('notification', {
      ...notification,
      timestamp: new Date().toISOString(),
    });
  }

  // 특정 방에 알림
  notifyRoom(roomId, notification) {
    this.io.to(roomId).emit('notification', {
      ...notification,
      timestamp: new Date().toISOString(),
    });
  }
}

module.exports = NotificationService;
```

### 5.2 알림 타입

```javascript
// 알림 타입 정의
const NotificationTypes = {
  MESSAGE: 'message',
  MENTION: 'mention',
  LIKE: 'like',
  COMMENT: 'comment',
  FOLLOW: 'follow',
  SYSTEM: 'system',
};

// 알림 생성 함수
function createNotification(type, recipientId, data) {
  return {
    id: generateId(),
    type,
    recipientId,
    ...data,
    timestamp: new Date().toISOString(),
    read: false,
  };
}

// 사용 예시
const notification = createNotification(
  NotificationTypes.MENTION,
  recipientUserId,
  {
    senderId: senderUserId,
    senderUsername: senderUsername,
    content: `@${recipientUsername} mentioned you!`,
    postId: postId,
  }
);
```

## 6. 실시간 데이터 동기화

### 6.1 데이터 동기화 패턴

```javascript
// Document Collaboration
class DocumentCollaborator {
  constructor(io) {
    this.io = io;
    this.documents = new Map();
    this.documents.set('doc-1', {
      content: 'Initial content',
      version: 1,
      collaborators: new Set(),
    });
  }

  connect(documentId, socket) {
    const document = this.documents.get(documentId);
    if (!document) return;

    document.collaborators.add(socket.userId);

    // 현재 문서 내용 전송
    socket.emit('document-init', {
      documentId,
      content: document.content,
      version: document.version,
      collaborators: Array.from(document.collaborators),
    });
  }

  update(documentId, userId, operation) {
    const document = this.documents.get(documentId);
    if (!document) return;

    // 오퍼레이션 적용
    document.content = applyOperation(document.content, operation);
    document.version++;

    // 모든 협력자에게 업데이트 전송
    this.io.to(documentId).emit('document-update', {
      documentId,
      operation,
      version: document.version,
      userId,
      timestamp: new Date().toISOString(),
    });
  }

  disconnect(documentId, socket) {
    const document = this.documents.get(documentId);
    if (!document) return;

    document.collaborators.delete(socket.userId);

    // 협력자 목록 업데이트
    this.io.to(documentId).emit('collaborators-update', {
      documentId,
      collaborators: Array.from(document.collaborators),
    });
  }
}

// 오퍼레이션 함수 (OT)
function applyOperation(content, operation) {
  switch (operation.type) {
    case 'insert':
      return content.slice(0, operation.position) +
             operation.text +
             content.slice(operation.position);
    case 'delete':
      return content.slice(0, operation.from) +
             content.slice(operation.to);
    case 'replace':
      return content.slice(0, operation.from) +
             operation.text +
             content.slice(operation.to);
    default:
      return content;
  }
}
```

## 7. 확장성 및 성능

### 7.1 Redis Pub/Sub

```javascript
// Redis Pub/Sub를 사용한 다중 서버 지원
const Redis = require('ioredis');
const { createAdapter } = require('@socket.io/redis-adapter');

const redis = new Redis();
const pubClient = new Redis();
const subClient = new Redis();

// Socket.IO Redis Adapter
const io = new Server({
  adapter: createAdapter({
    host: process.env.REDIS_HOST,
    port: process.env.REDIS_PORT,
  }),
});

// Redis Pub/Sub 사용
io.on('connection', (socket) => {
  // 채널 구독
  socket.on('subscribe', (channel) => {
    socket.join(channel);
  });

  socket.on('publish', ({ channel, message }) => {
    io.to(channel).emit('message', message);
  });
});
```

### 7.2 로드 밸런싱

```javascript
// Sticky Sessions를 사용한 로드 밸런싱
const { createServer } = require('http');
const { Server } = require('socket.io');

const httpServer = createServer();
const io = new Server(httpServer, {
  cors: {
    origin: '*',
    methods: ['GET', 'POST'],
  },
  pingTimeout: 60000,
  pingInterval: 25000,
  transports: ['websocket'],
});

// Redis Adapter 사용
io.adapter(createAdapter({
  host: process.env.REDIS_HOST,
  port: process.env.REDIS_PORT,
}));

httpServer.listen(3000, () => {
  console.log('Load balanced WebSocket server running');
});
```

## 8. 보안 고려사항

### 8.1 인증

```javascript
// 연결 시 인증
io.use(async (socket, next) => {
  const token = socket.handshake.auth.token;

  try {
    const decoded = verifyToken(token);
    socket.userId = decoded.userId;
    socket.username = decoded.username;
    next();
  } catch (error) {
    console.error('Authentication failed:', error);
    next(new Error('Authentication failed'));
  }
});

// 클라이언트에서 인증
const socket = io('http://localhost:3000', {
  auth: {
    token: 'jwt-token-here',
  },
});
```

### 8.2 유효성 검사

```javascript
// 메시지 유효성 검사
io.on('connection', (socket) => {
  socket.on('chat-message', async (data) => {
    // 콘텐츠 길이 제한
    if (data.content && data.content.length > 1000) {
      socket.emit('error', {
        message: 'Message too long. Maximum 1000 characters.',
      });
      return;
    }

    // 스팸 방지 (rate limiting)
    const canSend = await checkRateLimit(socket.userId);
    if (!canSend) {
      socket.emit('error', {
        message: 'Too many messages. Please wait before sending again.',
      });
      return;
    }

    // 유효성 검사 후 처리
    await handleChatMessage(socket, data);
  });
});
```

### 8.3 Rate Limiting

```javascript
// 메시지 속도 제한
const rateLimiter = new Map();

async function checkRateLimit(userId) {
  const now = Date.now();
  const userRates = rateLimiter.get(userId) || [];

  // 최근 1분 내의 메시지만 유지
  const recentMessages = userRates.filter(timestamp => {
    return now - timestamp < 60000;
  });

  if (recentMessages.length >= 10) {
    return false; // 1분에 최대 10개 메시지
  }

  recentMessages.push(now);
  rateLimiter.set(userId, recentMessages);

  return true;
}
```

## 9. 에러 처리 및 재연결

### 9.1 자동 재연결

```javascript
// 자동 재연결 설정
const socket = io('http://localhost:3000', {
  reconnection: true,
  reconnectionDelay: 1000,
  reconnectionAttempts: 5,
  reconnectionDelayMax: 5000,
});

// 연결 상태 모니터링
socket.on('reconnect', (attemptNumber) => {
  console.log(`Reconnected after ${attemptNumber} attempts`);
});

socket.on('reconnect_failed', () => {
  console.log('Reconnection failed');
});

socket.on('reconnect_attempt', (attemptNumber) => {
  console.log(`Reconnection attempt ${attemptNumber}`);
});
```

### 9.2 에러 처리

```javascript
// 서버 측 에러 처리
io.on('error', (error) => {
  console.error('Socket.IO error:', error);
});

io.on('connection_error', (error) => {
  console.error('Connection error:', error);
});

// 클라이언트 측 에러 처리
socket.on('error', (error) => {
  console.error('Socket error:', error);

  // 사용자에게 에러 알림
  alert('Connection error. Please refresh the page.');
});

socket.on('disconnect', (reason, details) => {
  console.log('Disconnected:', reason, details);

  switch (reason) {
    case 'io server disconnect':
      console.log('Server disconnected');
      // 자동 재연결 시도
      break;
    case 'io client disconnect':
      console.log('Client disconnected');
      break;
    case 'ping timeout':
      console.log('Ping timeout');
      break;
    case 'transport close':
      console.log('Transport closed');
      break;
    default:
      console.log('Unknown disconnect reason:', reason);
  }
});
```

## 10. 실전 팁

### 1. 하트비트 사용

```javascript
// 서버: 하트비트 사용
const wss = new WebSocket.Server({ 
  server, 
  path: '/ws'  // 하트비트 엔드포인트
});

// 클라이언트: 하트비트 사용
const socket = new WebSocket('wss://localhost:3000/ws');
```

### 2. 메시지 크기 제한

```javascript
// 메시지 크기 검사
const MAX_MESSAGE_SIZE = 1024 * 10; // 10KB

socket.on('message', (data) => {
  const messageSize = JSON.stringify(data).length;

  if (messageSize > MAX_MESSAGE_SIZE) {
    socket.send(JSON.stringify({
      type: 'error',
      message: 'Message too large. Maximum 10KB.',
    }));
    return;
  }

  // 메시지 처리
  handleMessage(data);
});
```

### 3. 연결 상태 관리

```javascript
// 연결 상태 추적
class ConnectionManager {
  constructor() {
    this.connections = new Map();
    this.stats = {
      totalConnections: 0,
      currentConnections: 0,
      messagesSent: 0,
      messagesReceived: 0,
    };
  }

  addConnection(socket) {
    this.connections.set(socket.id, socket);
    this.stats.totalConnections++;
    this.stats.currentConnections++;
  }

  removeConnection(socket) {
    this.connections.delete(socket.id);
    this.stats.currentConnections--;
  }

  getStats() {
    return { ...this.stats };
  }
}

const connectionManager = new ConnectionManager();

io.on('connection', (socket) => {
  socket.id = generateId();
  connectionManager.addConnection(socket);

  // 통계 수집
  socket.on('message', () => {
    connectionManager.stats.messagesReceived++;
  });

  socket.on('disconnect', () => {
    connectionManager.removeConnection(socket);
  });
});
```

### 4. 헬스 체크

```javascript
// WebSockets 연결 헬스 체크
setInterval(() => {
  const wssClients = Array.from(wss.clients)
    .filter(c => c.readyState === WebSocket.OPEN);

  wssClients.forEach(client => {
    // 핑� 전송
    client.send(JSON.stringify({ type: 'ping' }));
  });
}, 30000); // 30초마다

// 클라이언트에서 퐁응
let pingInterval;

socket.on('open', () => {
  console.log('Connected');

  pingInterval = setInterval(() => {
    socket.send(JSON.stringify({ type: 'pong' }));
  }, 15000); // 15초마다 퐁
});

socket.on('message', (data) => {
  if (data.type === 'ping') {
    // 퐁 응답
  }
});

socket.on('close', () => {
  clearInterval(pingInterval);
});
```

## 11. 결론

WebSockets는 실시간 애플리케이션을 구축하는 강력한 도구입니다. 올바른 패턴과 모범 사례를 따르면 안정적이고 확장 가능한 실시간 시스템을 구축할 수 있습니다.

**핵심 체크리스트:**

- :white_check_mark: 적절한 라이브러리 선택 (ws vs Socket.IO)
- :white_check_mark: Redis Pub/Sub로 확장성 확보
- :white_check_mark: 인증 및 유효성 검사 구현
- :white_check_mark: Rate Limiting으로 남용 방지
- :white_check_mark: 에러 처리 및 재연결 로직
- :white_check_mark: 하트비트 사용 (프로덕션 환경)
- :white_check_mark: 연결 상태 관리 및 모니터링

**참고 자료**
- [WebSocket API](https://developer.mozilla.org/en-US/docs/Web/API/WebSocket)
- [Socket.IO Documentation](https://socket.io/docs/)
- [ws Library](https://github.com/websockets/ws)
- [Real-time Web with WebSockets](https://www.oreilly.com/library/view/real-time-web-with/9781449331810/)
