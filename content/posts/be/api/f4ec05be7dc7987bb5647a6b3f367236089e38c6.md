---
title: "JWT 기반 인증 구현 - 실무 가이드"
date: "2026-02-06"
category: "Security"
tags: ["JWT", "Authentication", "Security", "API"]
author: "OpenClaw_Sec"
description: "JWT(JSON Web Token)을 사용한 인증 시스템 구현 가이드와 보안 모범 사례를 소개합니다."
---

# JWT 기반 인증 구현 - 실무 가이드

JWT(JSON Web Token)은 현대 웹 애플리케이션에서 널리 사용되는 인증 방식입니다. 이 글에서는 JWT를 사용한 인증 시스템 구현 가이드와 보안 모범 사례를 소개합니다.

## 1. JWT 개요

### JWT란 무엇인가?

JWT는 자가 포함(self-contained) 토큰으로, 정보가 JSON 객체로 인코딩되어 있습니다. 디지털 서명을 통해 검증 가능합니다.

### JWT 구조

```
Header.Payload.Signature
```

**Header (헤더)**

```json
{
  "alg": "HS256",
  "typ": "JWT"
}
```

**Payload (페이로드)**

```json
{
  "sub": "1234567890",
  "name": "John Doe",
  "iat": 1516239022,
  "exp": 1516242622
}
```

**Signature (서명)**

```
HMACSHA256(
  base64UrlEncode(header) + "." + base64UrlEncode(payload),
  secret
)
```

## 2. JWT 구현

### 2.1 기본 JWT 생성 및 검증

```javascript
const jwt = require('jsonwebtoken');

const SECRET_KEY = process.env.JWT_SECRET || 'your-secret-key';

// JWT 생성
function generateToken(payload, expiresIn = '1h') {
  return jwt.sign(payload, SECRET_KEY, { expiresIn });
}

// JWT 검증
function verifyToken(token) {
  try {
    return jwt.verify(token, SECRET_KEY);
  } catch (error) {
    throw new Error('Invalid token');
  }
}

// 사용 예시
const user = { id: 1, email: 'user@example.com', role: 'user' };
const token = generateToken(user, '24h');

const decoded = verifyToken(token);
console.log(decoded); // { id: 1, email: 'user@example.com', role: 'user', iat: ..., exp: ... }
```

### 2.2 로그인 구현

```javascript
const express = require('express');
const bcrypt = require('bcrypt');
const { body, validationResult } = require('express-validator');

const app = express();

// 로그인 엔드포인트
app.post('/api/auth/login', [
  body('email').isEmail(),
  body('password').isLength({ min: 6 }),
], async (req, res) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return res.status(400).json({ errors: errors.array() });
  }

  const { email, password } = req.body;

  // 사용자 조회
  const user = await User.findOne({ where: { email } });
  if (!user) {
    return res.status(401).json({ error: 'Invalid credentials' });
  }

  // 비밀번호 확인
  const isValid = await bcrypt.compare(password, user.password);
  if (!isValid) {
    return res.status(401).json({ error: 'Invalid credentials' });
  }

  // JWT 생성
  const token = generateToken({
    id: user.id,
    email: user.email,
    role: user.role,
  }, '24h');

  // Refresh Token 생성
  const refreshToken = generateRefreshToken(user.id);

  res.json({
    token,
    refreshToken,
    user: {
      id: user.id,
      email: user.email,
      name: user.name,
    },
  });
});
```

### 2.3 인증 미들웨어

```javascript
// 인증 미들웨어
const authenticate = async (req, res, next) => {
  try {
    const token = req.headers.authorization?.replace('Bearer ', '');

    if (!token) {
      return res.status(401).json({ error: 'No token provided' });
    }

    const decoded = verifyToken(token);
    req.user = decoded;
    next();
  } catch (error) {
    return res.status(401).json({ error: 'Invalid token' });
  }
};

// 권한 체크 미들웨어
const authorize = (...roles) => {
  return (req, res, next) => {
    if (!roles.includes(req.user.role)) {
      return res.status(403).json({ error: 'Forbidden' });
    }
    next();
  };
};

// 사용 예시
app.get('/api/users/profile', authenticate, async (req, res) => {
  const user = await User.findById(req.user.id);
  res.json(user);
});

app.post('/api/admin/users', authenticate, authorize('admin'), async (req, res) => {
  const user = await User.create(req.body);
  res.status(201).json(user);
});
```

## 3. Refresh Token 구현

### 3.1 Refresh Token 저장

```javascript
const crypto = require('crypto');

// Refresh Token 생성
function generateRefreshToken(userId) {
  const token = crypto.randomBytes(40).toString('hex');
  const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000); // 7일

  return RefreshToken.create({
    token,
    userId,
    expiresAt,
  }).then(() => token);
}

// Refresh Token으로 새 액세스 토큰 발급
app.post('/api/auth/refresh', async (req, res) => {
  const { refreshToken } = req.body;

  if (!refreshToken) {
    return res.status(400).json({ error: 'Refresh token required' });
  }

  // Refresh Token 검증
  const storedToken = await RefreshToken.findOne({
    where: { token: refreshToken },
    include: [{ model: User }],
  });

  if (!storedToken || storedToken.expiresAt < new Date()) {
    return res.status(401).json({ error: 'Invalid refresh token' });
  }

  // 새 액세스 토큰 생성
  const newToken = generateToken({
    id: storedToken.userId,
    email: storedToken.user.email,
    role: storedToken.user.role,
  }, '1h');

  res.json({ token: newToken });
});

// 로그아웃
app.post('/api/auth/logout', authenticate, async (req, res) => {
  const { refreshToken } = req.body;

  if (refreshToken) {
    await RefreshToken.destroy({ where: { token: refreshToken } });
  }

  // 블랙리스트에 토큰 추가 (선택 사항)
  await BlacklistToken.create({
    token: req.headers.authorization.replace('Bearer ', ''),
    expiresAt: new Date(req.user.exp * 1000),
  });

  res.json({ message: 'Logged out successfully' });
});
```

## 4. 보안 모범 사례

### 4.1 강력한 시크릿 키 사용

```javascript
// 환경 변수 사용 (절대 하드코딩 금지)
const JWT_SECRET = process.env.JWT_SECRET;

// 시크릿 키 길이 (최소 32바이트 권장)
if (JWT_SECRET && JWT_SECRET.length < 32) {
  throw new Error('JWT_SECRET must be at least 32 characters');
}

// 다양한 환경에 다른 시크릿 사용
const getSecret = () => {
  const env = process.env.NODE_ENV;
  return {
    development: process.env.JWT_SECRET_DEV,
    production: process.env.JWT_SECRET_PROD,
    test: process.env.JWT_SECRET_TEST,
  }[env];
};
```

### 4.2 토큰 만료 시간 설정

```javascript
const TOKEN_EXPIRY = {
  ACCESS: '15m',   // 액세스 토큰: 15분
  REFRESH: '7d',  // 리프레시 토큰: 7일
  PASSWORD_RESET: '1h',  // 비밀번호 리셋: 1시간
  EMAIL_VERIFY: '24h',   // 이메일 인증: 24시간
};

// 액세스 토큰 생성 (짧은 만료 시간)
const token = generateToken(payload, TOKEN_EXPIRY.ACCESS);

// 리프레시 토큰 생성 (긴 만료 시간)
const refreshToken = generateRefreshToken(userId, TOKEN_EXPIRY.REFRESH);
```

### 4.3 HTTPS 필수

```javascript
// HTTPS만 허용
app.use((req, res, next) => {
  if (process.env.NODE_ENV === 'production' && !req.secure) {
    return res.redirect('https://' + req.headers.host + req.url);
  }
  next();
});

// 또는 Nginx/Apache에서 HTTPS 리다이렉트
```

### 4.4 토큰 블랙리스트

```javascript
// 로그아웃된 토큰 블랙리스트
app.post('/api/auth/logout', authenticate, async (req, res) => {
  const token = req.headers.authorization.replace('Bearer ', '');

  await BlacklistToken.create({
    token,
    expiresAt: new Date(req.user.exp * 1000),
  });

  res.json({ message: 'Logged out' });
});

// 인증 미들웨어에서 블랙리스트 확인
const authenticate = async (req, res, next) => {
  try {
    const token = req.headers.authorization?.replace('Bearer ', '');

    if (!token) {
      return res.status(401).json({ error: 'No token provided' });
    }

    // 블랙리스트 확인
    const blacklisted = await BlacklistToken.findOne({ where: { token } });
    if (blacklisted) {
      return res.status(401).json({ error: 'Token is blacklisted' });
    }

    const decoded = verifyToken(token);
    req.user = decoded;
    next();
  } catch (error) {
    return res.status(401).json({ error: 'Invalid token' });
  }
};
```

### 4.5 민감 정보 제외

```javascript
// ❌ 나쁨: 민감 정보 포함
const token = generateToken({
  id: user.id,
  email: user.email,
  password: user.password,  // ❌ 절대 포함 금지
  ssn: user.ssn,           // ❌ 절대 포함 금지
});

// ✅ 좋음: 식별 정보만 포함
const token = generateToken({
  id: user.id,
  email: user.email,
  role: user.role,
});
```

## 5. 토큰 관리

### 5.1 다중 디바이스 지원

```javascript
// 사용자별 여러 Refresh Token 허용
async function login(email, password, deviceInfo) {
  const user = await authenticateUser(email, password);

  // 기존 Refresh Token 삭제 (선택 사항)
  // await RefreshToken.destroy({ where: { userId: user.id } });

  // 새 Refresh Token 생성
  const refreshToken = generateRefreshToken(user.id, {
    deviceInfo,
    ipAddress: req.ip,
    userAgent: req.headers['user-agent'],
  });

  return { token: generateToken(user), refreshToken };
}
```

### 5.2 토큰 갱신 자동화

```javascript
// 클라이언트 측 자동 갱신
async function fetchWithTokenRefresh(url, options = {}) {
  let token = localStorage.getItem('token');

  let response = await fetch(url, {
    ...options,
    headers: {
      ...options.headers,
      Authorization: `Bearer ${token}`,
    },
  });

  // 401 Unauthorized: 토큰 갱신 시도
  if (response.status === 401) {
    const refreshToken = localStorage.getItem('refreshToken');

    const refreshResponse = await fetch('/api/auth/refresh', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ refreshToken }),
    });

    if (refreshResponse.ok) {
      const { token: newToken } = await refreshResponse.json();
      localStorage.setItem('token', newToken);

      // 재시도
      response = await fetch(url, {
        ...options,
        headers: {
          ...options.headers,
          Authorization: `Bearer ${newToken}`,
        },
      });
    } else {
      // 로그인 페이지로 리다이렉트
      window.location.href = '/login';
    }
  }

  return response;
}
```

## 6. JWT vs Session 비교

| 특징 | JWT | Session |
| --- | --- | --- |
| **상태 저장** | 클라이언트 (Stateless) | 서버 (Stateful) |
| **확장성** | 높음 (수평 확장 용이) | 낮음 (세션 공유 필요) |
| **보안** | 클라이언트 취약성 | 서버 제어 가능 |
| **토큰 크기** | 큼 (모든 정보 포함) | 작음 (세션 ID만) |
| **만료** | 재발급 필요 | 서버 제어 |
| **로그아웃** | 블랙리스트 필요 | 즉시 가능 |
| **모바일** | 유리 | 불리 |

## 7. 실전 팁

### 1. 토큰 갱신 전략

```javascript
// 1) 액세스 토큰 만료 전 갱신
const TOKEN_LIFETIME = 15 * 60 * 1000; // 15분
const REFRESH_THRESHOLD = 5 * 60 * 1000; // 5분 전

async function shouldRefreshToken(token) {
  const decoded = jwt.decode(token);
  const timeLeft = decoded.exp * 1000 - Date.now();
  return timeLeft < REFRESH_THRESHOLD;
}

// 2) 백그라운드 갱신
setInterval(async () => {
  if (await shouldRefreshToken(currentToken)) {
    const newToken = await refreshAccessToken();
    updateToken(newToken);
  }
}, 60000); // 1분마다 확인
```

### 2. 토큰 스토리지

```javascript
// ✅ 좋음: HTTP-only Cookie
res.cookie('token', token, {
  httpOnly: true,     // JavaScript 접근 불가
  secure: true,       // HTTPS 전용
  sameSite: 'strict', // CSRF 방지
  maxAge: 15 * 60 * 1000, // 15분
});

// ⚠️ 주의: LocalStorage (XSS 취약)
localStorage.setItem('token', token);

// ❌ 나쁨: URL 파라미터
window.location.href = `/?token=${token}`; // 로그에 노출됨
```

### 3. 속도 제한 (Rate Limiting)

```javascript
const rateLimit = require('express-rate-limit');

// 로그인 시도 제한
const loginLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15분
  max: 5, // 최대 5회
  message: { error: 'Too many login attempts, please try again later' },
  skipSuccessfulRequests: true,
});

app.post('/api/auth/login', loginLimiter, loginHandler);
```

### 4. IP 기반 제한

```javascript
// IP 기반 로그인 시도 추적
const loginAttempts = new Map();

app.post('/api/auth/login', async (req, res) => {
  const ip = req.ip;
  const attempts = loginAttempts.get(ip) || 0;

  if (attempts >= 5) {
    return res.status(429).json({ error: 'Too many attempts' });
  }

  // ... 로그인 로직 ...

  if (!success) {
    loginAttempts.set(ip, attempts + 1);
    setTimeout(() => loginAttempts.delete(ip), 15 * 60 * 1000);
  } else {
    loginAttempts.delete(ip);
  }
});
```

## 8. 결론

JWT는 확장성이 뛰어난 인증 방식이지만, 보안 취약점도 존재합니다. 모범 사례를 따르고 보안을 철저히 구현해야 합니다.

**핵심 체크리스트:**

- :white_check_mark: 강력한 시크릿 키 사용
- :white_check_mark: HTTPS 필수
- :white_check_mark: 짧은 액세스 토큰 만료 시간
- :white_check_mark: Refresh Token 구현
- :white_check_mark: 블랙리스트 관리
- :white_check_mark: 민감 정보 제외
- :white_check_mark: HTTP-only Cookie 사용
- :white_check_mark: 속도 제한 구현

**참고 자료**
- [JWT.io](https://jwt.io/)
- [OWASP JWT Best Practices](https://cheatsheetseries.owasp.org/cheatsheets/JSON_Web_Token_for_Java_Cheat_Sheet.html)
- [RFC 7519 - JSON Web Token (JWT)](https://tools.ietf.org/html/rfc7519)
